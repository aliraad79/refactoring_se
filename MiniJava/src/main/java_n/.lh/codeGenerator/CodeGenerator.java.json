{
    "sourceFile": "codeGenerator/CodeGenerator.java",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1692098461314,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1692099215120,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,496 @@\n+package codeGenerator;\r\n+\r\n+import Log.Log;\r\n+import errorHandler.ErrorHandler;\r\n+import scanner.token.Token;\r\n+import semantic.symbol.Symbol;\r\n+import semantic.symbol.SymbolTable;\r\n+import semantic.symbol.SymbolType;\r\n+\r\n+import java.util.Stack;\r\n+\r\n+/**\r\n+ * Created by Alireza on 6/27/2015.\r\n+ */\r\n+public class CodeGenerator {\r\n+    private Memory memory = new Memory();\r\n+    private Stack<Address> ss = new Stack<Address>();\r\n+    private Stack<String> symbolStack = new Stack<>();\r\n+    private Stack<String> callStack = new Stack<>();\r\n+    private SymbolTable symbolTable;\r\n+\r\n+    public CodeGenerator() {\r\n+        symbolTable = new SymbolTable(memory);\r\n+        //TODO\r\n+    }\r\n+\r\n+    public void printMemory() {\r\n+        memory.pintCodeBlock();\r\n+    }\r\n+\r\n+    public void semanticFunction(int func, Token next) {\r\n+        Log.print(\"codegenerator : \" + func);\r\n+        switch (func) {\r\n+            case 0:\r\n+                return;\r\n+            case 1:\r\n+                checkID();\r\n+                break;\r\n+            case 2:\r\n+                pid(next);\r\n+                break;\r\n+            case 3:\r\n+                fpid();\r\n+                break;\r\n+            case 4:\r\n+                kpid(next);\r\n+                break;\r\n+            case 5:\r\n+                intpid(next);\r\n+                break;\r\n+            case 6:\r\n+                startCall();\r\n+                break;\r\n+            case 7:\r\n+                call();\r\n+                break;\r\n+            case 8:\r\n+                arg();\r\n+                break;\r\n+            case 9:\r\n+                assign();\r\n+                break;\r\n+            case 10:\r\n+                add();\r\n+                break;\r\n+            case 11:\r\n+                sub();\r\n+                break;\r\n+            case 12:\r\n+                mult();\r\n+                break;\r\n+            case 13:\r\n+                label();\r\n+                break;\r\n+            case 14:\r\n+                save();\r\n+                break;\r\n+            case 15:\r\n+                _while();\r\n+                break;\r\n+            case 16:\r\n+                jpf_save();\r\n+                break;\r\n+            case 17:\r\n+                jpHere();\r\n+                break;\r\n+            case 18:\r\n+                print();\r\n+                break;\r\n+            case 19:\r\n+                equal();\r\n+                break;\r\n+            case 20:\r\n+                less_than();\r\n+                break;\r\n+            case 21:\r\n+                and();\r\n+                break;\r\n+            case 22:\r\n+                not();\r\n+                break;\r\n+            case 23:\r\n+                defClass();\r\n+                break;\r\n+            case 24:\r\n+                defMethod();\r\n+                break;\r\n+            case 25:\r\n+                popClass();\r\n+                break;\r\n+            case 26:\r\n+                extend();\r\n+                break;\r\n+            case 27:\r\n+                defField();\r\n+                break;\r\n+            case 28:\r\n+                defVar();\r\n+                break;\r\n+            case 29:\r\n+                methodReturn();\r\n+                break;\r\n+            case 30:\r\n+                defParam();\r\n+                break;\r\n+            case 31:\r\n+                lastTypeBool();\r\n+                break;\r\n+            case 32:\r\n+                lastTypeInt();\r\n+                break;\r\n+            case 33:\r\n+                defMain();\r\n+                break;\r\n+        }\r\n+    }\r\n+\r\n+    private void defMain() {\r\n+        //ss.pop();\r\n+        memory.add3AddressCode(ss.pop().num, Operation.JP, new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null, null);\r\n+        String methodName = \"main\";\r\n+        String className = symbolStack.pop();\r\n+\r\n+        symbolTable.addMethod(className, methodName, memory.getCurrentCodeBlockAddress());\r\n+\r\n+        symbolStack.push(className);\r\n+        symbolStack.push(methodName);\r\n+    }\r\n+\r\n+    //    public void spid(Token next){\r\n+//        symbolStack.push(next.value);\r\n+//    }\r\n+    public void checkID() {\r\n+        symbolStack.pop();\r\n+        if (ss.peek().varType == varType.Non) {\r\n+            //TODO : error\r\n+        }\r\n+    }\r\n+\r\n+    public void pid(Token next) {\r\n+        if (symbolStack.size() > 1) {\r\n+            String methodName = symbolStack.pop();\r\n+            String className = symbolStack.pop();\r\n+            try {\r\n+\r\n+                Symbol s = symbolTable.get(className, methodName, next.value);\r\n+                varType t = varType.Int;\r\n+                switch (s.type) {\r\n+                    case Bool:\r\n+                        t = varType.Bool;\r\n+                        break;\r\n+                    case Int:\r\n+                        t = varType.Int;\r\n+                        break;\r\n+                }\r\n+                ss.push(new Address(s.address, t));\r\n+\r\n+\r\n+            } catch (Exception e) {\r\n+                ss.push(new Address(0, varType.Non));\r\n+            }\r\n+            symbolStack.push(className);\r\n+            symbolStack.push(methodName);\r\n+        } else {\r\n+            ss.push(new Address(0, varType.Non));\r\n+        }\r\n+        symbolStack.push(next.value);\r\n+    }\r\n+\r\n+    public void fpid() {\r\n+        ss.pop();\r\n+        ss.pop();\r\n+\r\n+        Symbol s = symbolTable.get(symbolStack.pop(), symbolStack.pop());\r\n+        varType t = varType.Int;\r\n+        switch (s.type) {\r\n+            case Bool:\r\n+                t = varType.Bool;\r\n+                break;\r\n+            case Int:\r\n+                t = varType.Int;\r\n+                break;\r\n+        }\r\n+        ss.push(new Address(s.address, t));\r\n+\r\n+    }\r\n+\r\n+    public void kpid(Token next) {\r\n+        ss.push(symbolTable.get(next.value));\r\n+    }\r\n+\r\n+    public void intpid(Token next) {\r\n+        ss.push(new Address(Integer.parseInt(next.value), varType.Int, TypeAddress.Imidiate));\r\n+    }\r\n+\r\n+    public void startCall() {\r\n+        //TODO: method ok\r\n+        ss.pop();\r\n+        ss.pop();\r\n+        String methodName = symbolStack.pop();\r\n+        String className = symbolStack.pop();\r\n+        symbolTable.startCall(className, methodName);\r\n+        callStack.push(className);\r\n+        callStack.push(methodName);\r\n+\r\n+        //symbolStack.push(methodName);\r\n+    }\r\n+\r\n+    public void call() {\r\n+        //TODO: method ok\r\n+        String methodName = callStack.pop();\r\n+        String className = callStack.pop();\r\n+        try {\r\n+            symbolTable.getNextParam(className, methodName);\r\n+            ErrorHandler.printError(\"The few argument pass for method\");\r\n+        } catch (IndexOutOfBoundsException e) {\r\n+        }\r\n+        varType t = varType.Int;\r\n+        switch (symbolTable.getMethodReturnType(className, methodName)) {\r\n+            case Int:\r\n+                t = varType.Int;\r\n+                break;\r\n+            case Bool:\r\n+                t = varType.Bool;\r\n+                break;\r\n+        }\r\n+        Address temp = new Address(memory.fetchTemp(), t);\r\n+        ss.push(temp);\r\n+        memory.add3AddressCode(Operation.ASSIGN, new Address(temp.num, varType.Address, TypeAddress.Imidiate), new Address(symbolTable.getMethodReturnAddress(className, methodName), varType.Address), null);\r\n+        memory.add3AddressCode(Operation.ASSIGN, new Address(memory.getCurrentCodeBlockAddress() + 2, varType.Address, TypeAddress.Imidiate), new Address(symbolTable.getMethodCallerAddress(className, methodName), varType.Address), null);\r\n+        memory.add3AddressCode(Operation.JP, new Address(symbolTable.getMethodAddress(className, methodName), varType.Address), null, null);\r\n+\r\n+        //symbolStack.pop();\r\n+    }\r\n+\r\n+    public void arg() {\r\n+        //TODO: method ok\r\n+\r\n+        String methodName = callStack.pop();\r\n+//        String className = symbolStack.pop();\r\n+        try {\r\n+            Symbol s = symbolTable.getNextParam(callStack.peek(), methodName);\r\n+            varType t = varType.Int;\r\n+            switch (s.type) {\r\n+                case Bool:\r\n+                    t = varType.Bool;\r\n+                    break;\r\n+                case Int:\r\n+                    t = varType.Int;\r\n+                    break;\r\n+            }\r\n+            Address param = ss.pop();\r\n+            if (param.varType != t) {\r\n+                ErrorHandler.printError(\"The argument type isn't match\");\r\n+            }\r\n+            memory.add3AddressCode(Operation.ASSIGN, param, new Address(s.address, t), null);\r\n+\r\n+//        symbolStack.push(className);\r\n+\r\n+        } catch (IndexOutOfBoundsException e) {\r\n+            ErrorHandler.printError(\"Too many arguments pass for method\");\r\n+        }\r\n+        callStack.push(methodName);\r\n+\r\n+    }\r\n+\r\n+    public void assign() {\r\n+        Address s1 = ss.pop();\r\n+        Address s2 = ss.pop();\r\n+//        try {\r\n+        if (s1.varType != s2.varType) {\r\n+            ErrorHandler.printError(\"The type of operands in assign is different \");\r\n+        }\r\n+//        }catch (NullPointerException d)\r\n+//        {\r\n+//            d.printStackTrace();\r\n+//        }\r\n+        memory.add3AddressCode(Operation.ASSIGN, s1, s2, null);\r\n+    }\r\n+\r\n+    public void add() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+\r\n+        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n+            ErrorHandler.printError(\"In add two operands must be integer\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.ADD, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void sub() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n+            ErrorHandler.printError(\"In sub two operands must be integer\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.SUB, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void mult() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n+            ErrorHandler.printError(\"In mult two operands must be integer\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.MULT, s1, s2, temp);\r\n+//        memory.saveMemory();\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void label() {\r\n+        ss.push(new Address(memory.getCurrentCodeBlockAddress(), varType.Address));\r\n+    }\r\n+\r\n+    public void save() {\r\n+        ss.push(new Address(memory.saveMemory(), varType.Address));\r\n+    }\r\n+\r\n+    public void _while() {\r\n+        memory.add3AddressCode(ss.pop().num, Operation.JPF, ss.pop(), new Address(memory.getCurrentCodeBlockAddress() + 1, varType.Address), null);\r\n+        memory.add3AddressCode(Operation.JP, ss.pop(), null, null);\r\n+    }\r\n+\r\n+    public void jpf_save() {\r\n+        Address save = new Address(memory.saveMemory(), varType.Address);\r\n+        memory.add3AddressCode(ss.pop().num, Operation.JPF, ss.pop(), new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null);\r\n+        ss.push(save);\r\n+    }\r\n+\r\n+    public void jpHere() {\r\n+        memory.add3AddressCode(ss.pop().num, Operation.JP, new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null, null);\r\n+    }\r\n+\r\n+    public void print() {\r\n+        memory.add3AddressCode(Operation.PRINT, ss.pop(), null, null);\r\n+    }\r\n+\r\n+    public void equal() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != s2.varType) {\r\n+            ErrorHandler.printError(\"The type of operands in equal operator is different\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.EQ, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void less_than() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n+            ErrorHandler.printError(\"The type of operands in less than operator is different\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.LT, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void and() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != varType.Bool || s2.varType != varType.Bool) {\r\n+            ErrorHandler.printError(\"In and operator the operands must be boolean\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.AND, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void not() {\r\n+        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n+        Address s2 = ss.pop();\r\n+        Address s1 = ss.pop();\r\n+        if (s1.varType != varType.Bool) {\r\n+            ErrorHandler.printError(\"In not operator the operand must be boolean\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.NOT, s1, s2, temp);\r\n+        ss.push(temp);\r\n+    }\r\n+\r\n+    public void defClass() {\r\n+        ss.pop();\r\n+        symbolTable.addClass(symbolStack.peek());\r\n+    }\r\n+\r\n+    public void defMethod() {\r\n+        ss.pop();\r\n+        String methodName = symbolStack.pop();\r\n+        String className = symbolStack.pop();\r\n+\r\n+        symbolTable.addMethod(className, methodName, memory.getCurrentCodeBlockAddress());\r\n+\r\n+        symbolStack.push(className);\r\n+        symbolStack.push(methodName);\r\n+    }\r\n+\r\n+    public void popClass() {\r\n+        symbolStack.pop();\r\n+    }\r\n+\r\n+    public void extend() {\r\n+        ss.pop();\r\n+        symbolTable.setSuperClass(symbolStack.pop(), symbolStack.peek());\r\n+    }\r\n+\r\n+    public void defField() {\r\n+        ss.pop();\r\n+        symbolTable.addField(symbolStack.pop(), symbolStack.peek());\r\n+    }\r\n+\r\n+    public void defVar() {\r\n+        ss.pop();\r\n+\r\n+        String var = symbolStack.pop();\r\n+        String methodName = symbolStack.pop();\r\n+        String className = symbolStack.pop();\r\n+\r\n+        symbolTable.addMethodLocalVariable(className, methodName, var);\r\n+\r\n+        symbolStack.push(className);\r\n+        symbolStack.push(methodName);\r\n+    }\r\n+\r\n+    public void methodReturn() {\r\n+        //TODO : call ok\r\n+\r\n+        String methodName = symbolStack.pop();\r\n+        Address s = ss.pop();\r\n+        SymbolType t = symbolTable.getMethodReturnType(symbolStack.peek(), methodName);\r\n+        varType temp = varType.Int;\r\n+        switch (t) {\r\n+            case Int:\r\n+                break;\r\n+            case Bool:\r\n+                temp = varType.Bool;\r\n+        }\r\n+        if (s.varType != temp) {\r\n+            ErrorHandler.printError(\"The type of method and return address was not match\");\r\n+        }\r\n+        memory.add3AddressCode(Operation.ASSIGN, s, new Address(symbolTable.getMethodReturnAddress(symbolStack.peek(), methodName), varType.Address, TypeAddress.Indirect), null);\r\n+        memory.add3AddressCode(Operation.JP, new Address(symbolTable.getMethodCallerAddress(symbolStack.peek(), methodName), varType.Address), null, null);\r\n+\r\n+        //symbolStack.pop();\r\n+    }\r\n+\r\n+    public void defParam() {\r\n+        //TODO : call Ok\r\n+        ss.pop();\r\n+        String param = symbolStack.pop();\r\n+        String methodName = symbolStack.pop();\r\n+        String className = symbolStack.pop();\r\n+\r\n+        symbolTable.addMethodParameter(className, methodName, param);\r\n+\r\n+        symbolStack.push(className);\r\n+        symbolStack.push(methodName);\r\n+    }\r\n+\r\n+    public void lastTypeBool() {\r\n+        symbolTable.setLastType(SymbolType.Bool);\r\n+    }\r\n+\r\n+    public void lastTypeInt() {\r\n+        symbolTable.setLastType(SymbolType.Int);\r\n+    }\r\n+\r\n+    public void main() {\r\n+\r\n+    }\r\n+}\r\n"
                }
            ],
            "date": 1692098461314,
            "name": "Commit-0",
            "content": "package codeGenerator;\r\n\r\nimport Log.Log;\r\nimport errorHandler.ErrorHandler;\r\nimport scanner.token.Token;\r\nimport semantic.symbol.Symbol;\r\nimport semantic.symbol.SymbolTable;\r\nimport semantic.symbol.SymbolType;\r\n\r\nimport java.util.Stack;\r\n\r\n/**\r\n * Created by Alireza on 6/27/2015.\r\n */\r\npublic class CodeGenerator {\r\n    private Memory memory = new Memory();\r\n    private Stack<Address> ss = new Stack<Address>();\r\n    private Stack<String> symbolStack = new Stack<>();\r\n    private Stack<String> callStack = new Stack<>();\r\n    private SymbolTable symbolTable;\r\n\r\n    public CodeGenerator() {\r\n        symbolTable = new SymbolTable(memory);\r\n        //TODO\r\n    }\r\n\r\n    public void printMemory() {\r\n        memory.pintCodeBlock();\r\n    }\r\n\r\n    public void semanticFunction(int func, Token next) {\r\n        Log.print(\"codegenerator : \" + func);\r\n        switch (func) {\r\n            case 0:\r\n                return;\r\n            case 1:\r\n                checkID();\r\n                break;\r\n            case 2:\r\n                pid(next);\r\n                break;\r\n            case 3:\r\n                fpid();\r\n                break;\r\n            case 4:\r\n                kpid(next);\r\n                break;\r\n            case 5:\r\n                intpid(next);\r\n                break;\r\n            case 6:\r\n                startCall();\r\n                break;\r\n            case 7:\r\n                call();\r\n                break;\r\n            case 8:\r\n                arg();\r\n                break;\r\n            case 9:\r\n                assign();\r\n                break;\r\n            case 10:\r\n                add();\r\n                break;\r\n            case 11:\r\n                sub();\r\n                break;\r\n            case 12:\r\n                mult();\r\n                break;\r\n            case 13:\r\n                label();\r\n                break;\r\n            case 14:\r\n                save();\r\n                break;\r\n            case 15:\r\n                _while();\r\n                break;\r\n            case 16:\r\n                jpf_save();\r\n                break;\r\n            case 17:\r\n                jpHere();\r\n                break;\r\n            case 18:\r\n                print();\r\n                break;\r\n            case 19:\r\n                equal();\r\n                break;\r\n            case 20:\r\n                less_than();\r\n                break;\r\n            case 21:\r\n                and();\r\n                break;\r\n            case 22:\r\n                not();\r\n                break;\r\n            case 23:\r\n                defClass();\r\n                break;\r\n            case 24:\r\n                defMethod();\r\n                break;\r\n            case 25:\r\n                popClass();\r\n                break;\r\n            case 26:\r\n                extend();\r\n                break;\r\n            case 27:\r\n                defField();\r\n                break;\r\n            case 28:\r\n                defVar();\r\n                break;\r\n            case 29:\r\n                methodReturn();\r\n                break;\r\n            case 30:\r\n                defParam();\r\n                break;\r\n            case 31:\r\n                lastTypeBool();\r\n                break;\r\n            case 32:\r\n                lastTypeInt();\r\n                break;\r\n            case 33:\r\n                defMain();\r\n                break;\r\n        }\r\n    }\r\n\r\n    private void defMain() {\r\n        //ss.pop();\r\n        memory.add3AddressCode(ss.pop().num, Operation.JP, new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null, null);\r\n        String methodName = \"main\";\r\n        String className = symbolStack.pop();\r\n\r\n        symbolTable.addMethod(className, methodName, memory.getCurrentCodeBlockAddress());\r\n\r\n        symbolStack.push(className);\r\n        symbolStack.push(methodName);\r\n    }\r\n\r\n    //    public void spid(Token next){\r\n//        symbolStack.push(next.value);\r\n//    }\r\n    public void checkID() {\r\n        symbolStack.pop();\r\n        if (ss.peek().varType == varType.Non) {\r\n            //TODO : error\r\n        }\r\n    }\r\n\r\n    public void pid(Token next) {\r\n        if (symbolStack.size() > 1) {\r\n            String methodName = symbolStack.pop();\r\n            String className = symbolStack.pop();\r\n            try {\r\n\r\n                Symbol s = symbolTable.get(className, methodName, next.value);\r\n                varType t = varType.Int;\r\n                switch (s.type) {\r\n                    case Bool:\r\n                        t = varType.Bool;\r\n                        break;\r\n                    case Int:\r\n                        t = varType.Int;\r\n                        break;\r\n                }\r\n                ss.push(new Address(s.address, t));\r\n\r\n\r\n            } catch (Exception e) {\r\n                ss.push(new Address(0, varType.Non));\r\n            }\r\n            symbolStack.push(className);\r\n            symbolStack.push(methodName);\r\n        } else {\r\n            ss.push(new Address(0, varType.Non));\r\n        }\r\n        symbolStack.push(next.value);\r\n    }\r\n\r\n    public void fpid() {\r\n        ss.pop();\r\n        ss.pop();\r\n\r\n        Symbol s = symbolTable.get(symbolStack.pop(), symbolStack.pop());\r\n        varType t = varType.Int;\r\n        switch (s.type) {\r\n            case Bool:\r\n                t = varType.Bool;\r\n                break;\r\n            case Int:\r\n                t = varType.Int;\r\n                break;\r\n        }\r\n        ss.push(new Address(s.address, t));\r\n\r\n    }\r\n\r\n    public void kpid(Token next) {\r\n        ss.push(symbolTable.get(next.value));\r\n    }\r\n\r\n    public void intpid(Token next) {\r\n        ss.push(new Address(Integer.parseInt(next.value), varType.Int, TypeAddress.Imidiate));\r\n    }\r\n\r\n    public void startCall() {\r\n        //TODO: method ok\r\n        ss.pop();\r\n        ss.pop();\r\n        String methodName = symbolStack.pop();\r\n        String className = symbolStack.pop();\r\n        symbolTable.startCall(className, methodName);\r\n        callStack.push(className);\r\n        callStack.push(methodName);\r\n\r\n        //symbolStack.push(methodName);\r\n    }\r\n\r\n    public void call() {\r\n        //TODO: method ok\r\n        String methodName = callStack.pop();\r\n        String className = callStack.pop();\r\n        try {\r\n            symbolTable.getNextParam(className, methodName);\r\n            ErrorHandler.printError(\"The few argument pass for method\");\r\n        } catch (IndexOutOfBoundsException e) {\r\n        }\r\n        varType t = varType.Int;\r\n        switch (symbolTable.getMethodReturnType(className, methodName)) {\r\n            case Int:\r\n                t = varType.Int;\r\n                break;\r\n            case Bool:\r\n                t = varType.Bool;\r\n                break;\r\n        }\r\n        Address temp = new Address(memory.fetchTemp(), t);\r\n        ss.push(temp);\r\n        memory.add3AddressCode(Operation.ASSIGN, new Address(temp.num, varType.Address, TypeAddress.Imidiate), new Address(symbolTable.getMethodReturnAddress(className, methodName), varType.Address), null);\r\n        memory.add3AddressCode(Operation.ASSIGN, new Address(memory.getCurrentCodeBlockAddress() + 2, varType.Address, TypeAddress.Imidiate), new Address(symbolTable.getMethodCallerAddress(className, methodName), varType.Address), null);\r\n        memory.add3AddressCode(Operation.JP, new Address(symbolTable.getMethodAddress(className, methodName), varType.Address), null, null);\r\n\r\n        //symbolStack.pop();\r\n    }\r\n\r\n    public void arg() {\r\n        //TODO: method ok\r\n\r\n        String methodName = callStack.pop();\r\n//        String className = symbolStack.pop();\r\n        try {\r\n            Symbol s = symbolTable.getNextParam(callStack.peek(), methodName);\r\n            varType t = varType.Int;\r\n            switch (s.type) {\r\n                case Bool:\r\n                    t = varType.Bool;\r\n                    break;\r\n                case Int:\r\n                    t = varType.Int;\r\n                    break;\r\n            }\r\n            Address param = ss.pop();\r\n            if (param.varType != t) {\r\n                ErrorHandler.printError(\"The argument type isn't match\");\r\n            }\r\n            memory.add3AddressCode(Operation.ASSIGN, param, new Address(s.address, t), null);\r\n\r\n//        symbolStack.push(className);\r\n\r\n        } catch (IndexOutOfBoundsException e) {\r\n            ErrorHandler.printError(\"Too many arguments pass for method\");\r\n        }\r\n        callStack.push(methodName);\r\n\r\n    }\r\n\r\n    public void assign() {\r\n        Address s1 = ss.pop();\r\n        Address s2 = ss.pop();\r\n//        try {\r\n        if (s1.varType != s2.varType) {\r\n            ErrorHandler.printError(\"The type of operands in assign is different \");\r\n        }\r\n//        }catch (NullPointerException d)\r\n//        {\r\n//            d.printStackTrace();\r\n//        }\r\n        memory.add3AddressCode(Operation.ASSIGN, s1, s2, null);\r\n    }\r\n\r\n    public void add() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n\r\n        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n            ErrorHandler.printError(\"In add two operands must be integer\");\r\n        }\r\n        memory.add3AddressCode(Operation.ADD, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void sub() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n            ErrorHandler.printError(\"In sub two operands must be integer\");\r\n        }\r\n        memory.add3AddressCode(Operation.SUB, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void mult() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Int);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n            ErrorHandler.printError(\"In mult two operands must be integer\");\r\n        }\r\n        memory.add3AddressCode(Operation.MULT, s1, s2, temp);\r\n//        memory.saveMemory();\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void label() {\r\n        ss.push(new Address(memory.getCurrentCodeBlockAddress(), varType.Address));\r\n    }\r\n\r\n    public void save() {\r\n        ss.push(new Address(memory.saveMemory(), varType.Address));\r\n    }\r\n\r\n    public void _while() {\r\n        memory.add3AddressCode(ss.pop().num, Operation.JPF, ss.pop(), new Address(memory.getCurrentCodeBlockAddress() + 1, varType.Address), null);\r\n        memory.add3AddressCode(Operation.JP, ss.pop(), null, null);\r\n    }\r\n\r\n    public void jpf_save() {\r\n        Address save = new Address(memory.saveMemory(), varType.Address);\r\n        memory.add3AddressCode(ss.pop().num, Operation.JPF, ss.pop(), new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null);\r\n        ss.push(save);\r\n    }\r\n\r\n    public void jpHere() {\r\n        memory.add3AddressCode(ss.pop().num, Operation.JP, new Address(memory.getCurrentCodeBlockAddress(), varType.Address), null, null);\r\n    }\r\n\r\n    public void print() {\r\n        memory.add3AddressCode(Operation.PRINT, ss.pop(), null, null);\r\n    }\r\n\r\n    public void equal() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != s2.varType) {\r\n            ErrorHandler.printError(\"The type of operands in equal operator is different\");\r\n        }\r\n        memory.add3AddressCode(Operation.EQ, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void less_than() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != varType.Int || s2.varType != varType.Int) {\r\n            ErrorHandler.printError(\"The type of operands in less than operator is different\");\r\n        }\r\n        memory.add3AddressCode(Operation.LT, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void and() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != varType.Bool || s2.varType != varType.Bool) {\r\n            ErrorHandler.printError(\"In and operator the operands must be boolean\");\r\n        }\r\n        memory.add3AddressCode(Operation.AND, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void not() {\r\n        Address temp = new Address(memory.fetchTemp(), varType.Bool);\r\n        Address s2 = ss.pop();\r\n        Address s1 = ss.pop();\r\n        if (s1.varType != varType.Bool) {\r\n            ErrorHandler.printError(\"In not operator the operand must be boolean\");\r\n        }\r\n        memory.add3AddressCode(Operation.NOT, s1, s2, temp);\r\n        ss.push(temp);\r\n    }\r\n\r\n    public void defClass() {\r\n        ss.pop();\r\n        symbolTable.addClass(symbolStack.peek());\r\n    }\r\n\r\n    public void defMethod() {\r\n        ss.pop();\r\n        String methodName = symbolStack.pop();\r\n        String className = symbolStack.pop();\r\n\r\n        symbolTable.addMethod(className, methodName, memory.getCurrentCodeBlockAddress());\r\n\r\n        symbolStack.push(className);\r\n        symbolStack.push(methodName);\r\n    }\r\n\r\n    public void popClass() {\r\n        symbolStack.pop();\r\n    }\r\n\r\n    public void extend() {\r\n        ss.pop();\r\n        symbolTable.setSuperClass(symbolStack.pop(), symbolStack.peek());\r\n    }\r\n\r\n    public void defField() {\r\n        ss.pop();\r\n        symbolTable.addField(symbolStack.pop(), symbolStack.peek());\r\n    }\r\n\r\n    public void defVar() {\r\n        ss.pop();\r\n\r\n        String var = symbolStack.pop();\r\n        String methodName = symbolStack.pop();\r\n        String className = symbolStack.pop();\r\n\r\n        symbolTable.addMethodLocalVariable(className, methodName, var);\r\n\r\n        symbolStack.push(className);\r\n        symbolStack.push(methodName);\r\n    }\r\n\r\n    public void methodReturn() {\r\n        //TODO : call ok\r\n\r\n        String methodName = symbolStack.pop();\r\n        Address s = ss.pop();\r\n        SymbolType t = symbolTable.getMethodReturnType(symbolStack.peek(), methodName);\r\n        varType temp = varType.Int;\r\n        switch (t) {\r\n            case Int:\r\n                break;\r\n            case Bool:\r\n                temp = varType.Bool;\r\n        }\r\n        if (s.varType != temp) {\r\n            ErrorHandler.printError(\"The type of method and return address was not match\");\r\n        }\r\n        memory.add3AddressCode(Operation.ASSIGN, s, new Address(symbolTable.getMethodReturnAddress(symbolStack.peek(), methodName), varType.Address, TypeAddress.Indirect), null);\r\n        memory.add3AddressCode(Operation.JP, new Address(symbolTable.getMethodCallerAddress(symbolStack.peek(), methodName), varType.Address), null, null);\r\n\r\n        //symbolStack.pop();\r\n    }\r\n\r\n    public void defParam() {\r\n        //TODO : call Ok\r\n        ss.pop();\r\n        String param = symbolStack.pop();\r\n        String methodName = symbolStack.pop();\r\n        String className = symbolStack.pop();\r\n\r\n        symbolTable.addMethodParameter(className, methodName, param);\r\n\r\n        symbolStack.push(className);\r\n        symbolStack.push(methodName);\r\n    }\r\n\r\n    public void lastTypeBool() {\r\n        symbolTable.setLastType(SymbolType.Bool);\r\n    }\r\n\r\n    public void lastTypeInt() {\r\n        symbolTable.setLastType(SymbolType.Int);\r\n    }\r\n\r\n    public void main() {\r\n\r\n    }\r\n}\r\n"
        }
    ]
}